#version 460 core

#extension GL_EXT_shader_16bit_storage : require

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform Camera {
  mat4 projection;
  mat4 view;
  vec3 camera_position;
  float pad0;
  uvec2 screen_size;  // (width, height)
};

layout(push_constant, std430) uniform PushConstants { mat4 model; };

layout(set = 1, binding = 0) uniform Info { uint point_count; };

layout(std430, set = 1, binding = 1) readonly buffer GaussianPosition {
  float gaussian_position[];  // (N, 3)
};

layout(std430, set = 1, binding = 2) readonly buffer GaussianCov3d {
  float gaussian_cov3d[];  // (N, 6)
};

layout(std430, set = 1, binding = 3) readonly buffer GaussianOpacity {
  float gaussian_opacity[];  // (N)
};

layout(std430, set = 1, binding = 4) readonly buffer GaussianSh {
  f16vec4 gaussian_sh[];  // (N, 3, 4, 4), 16 values packed with 4 vec4.
};

layout(std430, set = 2, binding = 0) writeonly buffer DrawIndirect {
  uint indexCount;
  uint instanceCount;
  uint firstIndex;
  int vertexOffset;
  uint firstInstance;
  uint pad[3];

  // draw indirect
  uint vertexCount1;
  uint instanceCount1;
  uint firstVertex1;
  uint firstInstance1;
};

layout(std430, set = 2, binding = 1) writeonly buffer Instances {
  float instances[];  // (N, 10). 3 for ndc position, 3 for scale rot, 4 for color
};

layout(std430, set = 2, binding = 2) buffer VisiblePointCount {
  uint visible_point_count;
};

layout(std430, set = 2, binding = 5) readonly buffer InverseMap {
  int inverse_map[];  // (N), inverse map from id to sorted index
};

void main() {
  uint id = gl_GlobalInvocationID.x;
  if (id >= point_count) return;

  if (id == 0) {
    indexCount = 6 * visible_point_count;
    instanceCount = 1;
    firstIndex = 0;
    vertexOffset = 0;
    firstInstance = 0;

    vertexCount1 = visible_point_count;
    instanceCount1 = 1;
    firstVertex1 = 0;
    firstInstance1 = 0;
  }

  int inverse_id = inverse_map[id];
  if (inverse_id == -1) return;

  vec3 v0 = vec3(gaussian_cov3d[id * 6 + 0], gaussian_cov3d[id * 6 + 1], gaussian_cov3d[id * 6 + 2]);
  vec3 v1 = vec3(gaussian_cov3d[id * 6 + 3], gaussian_cov3d[id * 6 + 4], gaussian_cov3d[id * 6 + 5]);
  vec4 pos = vec4(gaussian_position[id * 3 + 0], gaussian_position[id * 3 + 1], gaussian_position[id * 3 + 2], 1.f);

  // direction in model space for SH calculation
  vec4 camera_podel_position = inverse(model) * vec4(camera_position, 1.f);
  camera_podel_position = camera_podel_position / camera_podel_position.w;
  vec3 dir = normalize(pos.xyz - camera_podel_position.xyz);

  // [v0.x v0.y v0.z]
  // [v0.y v1.x v1.y]
  // [v0.z v1.y v1.z]
  mat3 cov3d = mat3(v0, v0.y, v1.xy, v0.z, v1.yz);

  // model matrix
  mat3 model3d = mat3(model);
  cov3d = model3d * cov3d * transpose(model3d);
  pos = model * pos;

  // view matrix
  mat3 view3d = mat3(view);
  cov3d = view3d * cov3d * transpose(view3d);
  pos = view * pos;

  // projection
  float r = length(vec3(pos));
  mat3 J = mat3(-1.f / pos.z, 0.f, -2.f * pos.x / r, 0.f, -1.f / pos.z,
                -2.f * pos.y / r, pos.x / pos.z / pos.z, pos.y / pos.z / pos.z,
                -2.f * pos.z / r);
  cov3d = J * cov3d * transpose(J);

  // projection xy
  mat2 projection_scale = mat2(projection);
  mat2 cov2d = projection_scale * mat2(cov3d) * projection_scale;

  // low-pass filter
  cov2d[0][0] += 1.f / screen_size.x / screen_size.x;
  cov2d[1][1] += 1.f / screen_size.y / screen_size.y;

  // eigendecomposition
  // [a c] = [x y]
  // [c b]   [y z]
  float a = cov2d[0][0];
  float b = cov2d[1][1];
  float c = cov2d[1][0];
  float D = sqrt((a - b) * (a - b) + 4.f * c * c);
  float s0 = sqrt(0.5f * (a + b + D));
  float s1 = sqrt(0.5f * (a + b - D));
  // decompose to R^T S^2 R
  float sin2t = 2.f * c / D;
  float cos2t = (a - b) / D;
  float theta = atan(sin2t, cos2t) / 2.f;

  pos = projection * pos;
  pos = pos / pos.w;

  // calculate spherical harmonics
  const float C0 = 0.28209479177387814f;
  const float C1 = 0.4886025119029199f;

  float x = dir.x;
  float y = dir.y;
  float z = dir.z;
  vec4 basis0 = vec4(C0, -C1 * y, C1 * z, -C1 * x);
  mat3x4 sh0 = mat3x4(gaussian_sh[id * 12 + 0], gaussian_sh[id * 12 + 4], gaussian_sh[id * 12 + 8]);
  // row vector-matrix multiplication
  vec3 color = basis0 * sh0 ;

  // translation and clip
  color = max(color + 0.5f, 0.f);
  float opacity = gaussian_opacity[id];

  instances[inverse_id * 10 + 0] = pos.x;
  instances[inverse_id * 10 + 1] = pos.y;
  instances[inverse_id * 10 + 2] = pos.z;
  instances[inverse_id * 10 + 3] = s0;
  instances[inverse_id * 10 + 4] = s1;
  instances[inverse_id * 10 + 5] = theta;
  instances[inverse_id * 10 + 6] = color.r;
  instances[inverse_id * 10 + 7] = color.g;
  instances[inverse_id * 10 + 8] = color.b;
  instances[inverse_id * 10 + 9] = opacity;
}
